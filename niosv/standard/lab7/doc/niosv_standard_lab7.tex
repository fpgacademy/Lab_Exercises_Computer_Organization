\documentclass[epsfig,10pt,fullpage]{article}

\newcommand{\LabNum}{7}
\newcommand{\CommonDocsPath}{../../../../common/docs}
\input{\CommonDocsPath/preamble.tex}

\begin{document}

\centerline{\huge Computer Organization}
~\\
\centerline{\huge Laboratory Exercise \LabNum}
~\\
\centerline{\large Using Interrupts with C code}
~\\

The purpose of this exercise is to investigate the use of interrupts for the 
Nios\textsuperscript{\textregistered}~V processor, using C code. To do 
this exercise you need to be familiar with the Nios~V {\it trap} processing mechanisms.
They are described in the document entitled {\it Introduction to Nios~V}, 
available as part of the \texttt{Computer Organization and System Design} tutorials in the 
{\href{https://www.fpgacademy.org/tutorials.html} {FPGAcademy.org}} website.
We assume that you are using the {\it DE1-SoC Computer System with Nios~V},
which is described as part of the \texttt{Computer Organization} course on
{\href{https://www.fpgacademy.org/courses.html} {FPGAcademy.org}}. Make sure that you are
familiar with the parts of the DE1-SoC Computer System documentation that are about
interrupts.  A good approach is to first implement each part of this exercise by 
using the {\it CPUlator} simulator, and then to implement your solution in a hardware board,
if available.  If a hardware system other than the DE1-SoC Computer is being used, then 
some parts of this exercise may need to be modified to suit the features of your board. 

~\\
This exercise involves the same tasks as those given in Laboratory Exercise 5,
except that this exercise uses C code rather than assembly-language code.

\section*{Part I}
\addcontentsline{toc}{1}{Part I}

The main program shown in Figure~\ref{fig:code} gives an example of the use of Nios~V interrupts
with C code.  Lines~1 to~3 in the code declare some function prototypes that are needed in 
the program. The function prototype for the {\it handler} subroutine, which is the trap 
handler in this program, is assigned the attribute \texttt{interrupt ("machine")}. This 
attribute instructs the C compiler to generate the appropriate assembly-language code for 
a trap (interrupt) handler: the assembly-language code that implements {\it handler} will save
and restore all registers (using the stack) that could be modified while the interrupt is 
being handled, and will return to the main program by using the \texttt{mret} instruction.

~\\
The main program declares pointers for accessing I/O devices in Lines~10 and~11. These
pointers are given the \texttt{volatile} keyword, which tells the compiler that the
value of the variables may change at any time, even if not modified in the code where
they are declared. Line~14 in the code call a subroutine that enable interrupts in the 
KEY pushbutton port. 

~\\
Interrupts are enabled in the C code in Lines~16 to~28 by inserting assembly-language code 
using the GNU C-compiler's \texttt{\_\_asm\_\_} inline assembly capability. The steps performed by
these lines of code are: first, disable Nios~V interrupts by clearing the {\it interrupt} bit in the
{\it mstatus} control register (Line~19), write the {\it handler} address into the {\it mtvec}  
control register (Lines~20 and~21), clear any interrupt bits currently set in the {\it mie} 
control register (Lines~23 and~24), set the enable bit for the {\it KEY} pushbutton port (bit 18)
in the {\it mie} register (Lines~25 and~26), and, finally, enable Nios~V interrupts by setting the
{\it interrupt} bit in the {\it mstatus} register (Line~28).

~\\
Inline assembly-language code is also used in Line~39 of the {\it handler} routine, shown
in Figure~\ref{fig:trap}, to read the Nios~V {\it mcause} register.
The handler then checks to see that a KEY interrupt has occurred, and then calls the 
{\it KEY\_ISR} interrupt service routine. As mentioned above, the {\it handler} will save and 
restores all temporary registers, and return to the main program using the \texttt{mret} 
instruction, because the handler is declared with the \texttt{interrupt ("machine")} attribute.

~\\
Put the code from Figures~\ref{fig:code} and~\ref{fig:trap} into a file named {\it part1.c}. 
This code is provided as part of the {\it Design Files} for this laboratory exercise. 
Compile and run this program.  You should examine the assembly-language code generated by the 
C compiler and ensure that you understand how the interrupt mechanisms are implemented. 

\begin{figure}[H]
\begin{center}
\begin{minipage}[h]{14.5 cm}
\lstinputlisting[language=C, firstline=6, lastline=40, numbers=left] {../design_files/part1.c}
\caption{Main program for Part 1.}
\label{fig:code}
\end{minipage}
\end{center}
\end{figure}

\begin{figure}[t]
\begin{center}
\begin{minipage}[h]{14.5 cm}
\lstinputlisting[language=C, firstline=42, firstnumber=last, numbers=left] 
{../design_files/part1.c}
\caption{Trap handler and subroutines for Part 1.}
\label{fig:trap}
\end{minipage}
\end{center}
\end{figure}

\section*{ Part II}
\addcontentsline{toc}{2}{Part II}
Consider the main program shown in Figure~\ref{fig:code2}. The code is required to set up 
interrupts from two sources: the Nios~V Machine Timer and the KEY pushbutton port. The main
program calls the subroutines {\it set\_mtimer( )} and {\it set\_KEY( )} to set up the two ports. 
You are to write each of these subroutines. Set up the Machine Timer to generate one interrupt
every 0.25 seconds.

~\\
In Figure~\ref{fig:code2} the main program executes an endless loop writing the value of
the global variable {\it count} to the red lights \red{{\it LEDR}}.
In the interrupt handling code for 
the Machine Timer you are to increment the variable {\it count} by the value of the 
{\it run} global variable, which should be either 1 or 0. You are to toggle the value of the
{\it run} global variable in the interrupt handling code for the {\it KEY} pushbuttons, each time 
a {\it KEY} is pressed. When {\it run} = 0, the main program will display a static count on the 
red lights, and when {\it run} = 1, the count shown on the red lights will increment every 
0.25 seconds.

~\\
Type your code in a file named {\it part2}.c. Compile, debug, and test your solution.

\section*{ Part III}
\addcontentsline{toc}{3}{Part III}
Modify your program from Part II so that you can vary the speed at which the counter
displayed on the red lights is incremented. All of your changes for this part should be made
in the interrupt handling code for the {\it KEY} pushbutton. The main program and the rest of
your code should not have to be changed.

~\\
Implement the following behavior. When {\it KEY}$_0$ is pressed, the value of the {\it run}
variable should be toggled, as in Part I. Hence, pressing {\it KEY}$_0$ stops/runs
the incrementing of the {\it count} variable. When {\it KEY}$_1$ is pressed, the rate at which
the Machine Timer is running, and hence the rate at which the \red{{\it LEDR}} lights are 
changing, should be {\it doubled}. Finally, When {\it KEY}$_2$ is pressed the rate of the 
Machine Timer should be {\it halved}. 

\section*{ Part IV}
\addcontentsline{toc}{4}{Part IV}
For this part you are to create a real-time clock that is shown on the seven-segment 
displays \red{{\it HEX5-0}}. Set up the Nios~V Machine Timer to provide an interrupt every 
1/100 of a second. Use this timer to increment a global variable called {\it time}, which
serves as your real-time clock. Use the format \red{MM}:\red{SS}:\red{DD}, where 
\red{\it MM} are minutes, \red{\it SS} are seconds and \red{\it DD} are hundredths of a second.
When the clock reaches \red{59}:\red{59}:\red{99}, it should wrap around to 
\red{00}:\red{00}:\red{00}.

~\\
Write your code for the real-time clock in a file called {\it part4.c}. To show the 
{\it time} variable in the format \red{\it MM}:\red{SS}:\red{DD}, you can use the same 
approach that was followed for Part 4 of Laboratory Exercise 6.
In that previous exercise you used polled I/O with the Machine Timer,
whereas now you are using interrupts. One possible way to structure your code is illustrated in
Figure~\ref{fig:code4}. The endless loop in this code writes the value of a variable named
{\it HEX\_code} to the {\it HEX}$3-0$ displays.

~\\
Using the scheme in Figure~\ref{fig:code4}, the interrupt handling code for the 
Machine Timer only has to increment the {\it time} variable.

~\\
Compile, debug, and test your code.

\begin{figure}[ ]
\begin{center}
\lstinputlisting[language=C]{../design_files/part2.c}
\end{center}
\vspace{-1.cm}\caption{Main program for Part II.}
\label{fig:code2}
\end{figure}

\begin{figure}[ ]
\begin{center}
\begin{minipage}[h]{15.5 cm}
\lstinputlisting[language=C, escapechar=|]{../design_files/part4.c}
\vspace{-0cm}\caption{Main program for Part IV.}
\label{fig:code4}
\end{minipage}
\end{center}
\end{figure}



\input{\CommonDocsPath/copyright.tex}
\end{document}
